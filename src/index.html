<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Table Sitting Solver</title>
    <style>
        /* Add some basic styling */
        .person-section {
            border: 1px solid #ccc;
            padding: 10px;
            margin-bottom: 10px;
        }

        .preference-list>div {
            /* Style each neighbor line */
            margin-left: 20px;
            margin-bottom: 5px;
        }

        .preference-list label {
            /* Make labels inline */
            /* display: block; */
            /* margin-left: 20px; */
            margin-right: 5px;
            /* Space after checkbox */
        }

        .neighbor-name {
            display: inline-block;
            min-width: 100px;
            /* Adjust as needed */
        }

        .pref-controls {
            display: inline-block;
            margin-left: 15px;
        }

        .pref-controls label {
            font-size: 0.9em;
        }

        .pref-controls input[type="checkbox"] {
            margin-right: 2px;
        }
    </style>
</head>

<body>
    <h1>Table Sitting Solver</h1>

    <h2>Define Preferences</h2>
    <form>
        <div>
            <label for="personName">Person Name:</label>
            <input type="text" id="personName" name="personName">
            <button type="button" id="addPersonBtn">Add Person</button>
            <button type="button" id="clearAllBtn" style="margin-left: 10px;">Clear All</button>
        </div>

        <div id="peopleContainer">
            <!-- People and their preferences will be added here -->
        </div>

        <!-- REMOVED Solve Button -->
        <!-- <button type="submit">Solve Sitting Arrangement</button> -->
    </form>

    <hr> <!-- Separator -->

    <div id="resultsContainer">
        <!-- Results will be displayed here -->
        <p>Add people and select preferences to see the results.</p>
    </div>


    <script type="module">
        import GLPK from 'https://cdn.jsdelivr.net/npm/glpk.js@4.0.2/dist/index.js';
        // Import the solver function from the external module
        import { solveSitting } from './solve_sitting.mjs';

        // --- Constants ---
        const DEBOUNCE_DELAY = 500; // ms
        const STORAGE_KEY_PEOPLE = 'tabletetris_people';
        const STORAGE_KEY_PREFS = 'tabletetris_prefs';
        const PREFERENCE_VALUE_CHECKED = 1;  // Value for "Want"
        const PREFERENCE_VALUE_DISLIKE = -1; // Value for "Don't Want"

        // --- Enhanced SVG Constants ---
        const TABLE_RADIUS = 80;         // px - Radius of the table circle
        const TABLE_PADDING = 50;        // px - Space between table visualization edges
        const PERSON_FONT_SIZE = 12;     // px - Smaller font for names
        const PERSON_CIRCLE_RADIUS = 8; // px - Radius of the circle representing a person
        const PERSON_TEXT_OFFSET = 10;   // px - Distance from person circle edge to text start
        const TOP_PADDING = 30;          // px - Increased space above the tables

        // --- Color Palette ---
        const TABLE_STROKE_COLOR = '#4a4a4a'; // Darker grey for table outline
        const TABLE_FILL_COLOR = '#f0f0f0';   // Light grey fill for table
        const PERSON_FILL_COLOR = '#5b9bd5';  // A pleasant blue for person markers
        const TEXT_COLOR = '#333';          // Dark grey text for better readability

        // --- Global State ---
        let people = []; // Array to store person objects { id: number, name: string }
        let nextPersonId = 0;
        // Store want/dislike states { 'pref_want_A_B': true/false, 'pref_dislike_A_B': true/false }
        let preferencesState = {};
        let glpk = null; // To store the initialized GLPK instance
        let solveTimeoutId = null; // For debouncing

        // --- DOM Elements ---
        const personNameInput = document.getElementById('personName');
        const addPersonBtn = document.getElementById('addPersonBtn');
        const peopleContainer = document.getElementById('peopleContainer');
        const resultsContainer = document.getElementById('resultsContainer');
        const clearAllBtn = document.getElementById('clearAllBtn');

        // --- Utility Functions ---
        function debounce(func, delay) {
            return function (...args) {
                clearTimeout(solveTimeoutId);
                solveTimeoutId = setTimeout(() => {
                    func.apply(this, args);
                }, delay);
            };
        }

        // --- LocalStorage ---
        function saveState() {
            try {
                localStorage.setItem(STORAGE_KEY_PEOPLE, JSON.stringify(people));
                // Need to gather state from potentially unchecked boxes too now
                preferencesState = {}; // Reset
                const allCheckboxes = peopleContainer.querySelectorAll('input[type="checkbox"]');
                allCheckboxes.forEach(checkbox => {
                    preferencesState[checkbox.name] = checkbox.checked;
                });

                localStorage.setItem(STORAGE_KEY_PREFS, JSON.stringify(preferencesState));
                console.log("[DEBUG] State saved to localStorage:", preferencesState);

            } catch (e) {
                console.error("Failed to save state to localStorage:", e);
            }
        }

        function loadState() {
            try {
                const storedPeople = localStorage.getItem(STORAGE_KEY_PEOPLE);
                const storedPrefs = localStorage.getItem(STORAGE_KEY_PREFS);

                if (storedPeople) {
                    people = JSON.parse(storedPeople);
                    nextPersonId = people.reduce((maxId, p) => Math.max(maxId, p.id), -1) + 1;
                    console.log("[DEBUG] Loaded people:", people);
                } else {
                    people = [];
                    nextPersonId = 0;
                }

                if (storedPrefs) {
                    preferencesState = JSON.parse(storedPrefs);
                    // Remove migration logic - incompatible format change
                    console.log("[DEBUG] Loaded preferences state:", preferencesState);
                } else {
                    preferencesState = {};
                }

                rebuildUI();

                if (people.length > 0) {
                    console.log("[DEBUG] Triggering initial solve after loading state.");
                    debouncedTriggerSolutionUpdate();
                }

            } catch (e) {
                console.error("Failed to load state from localStorage:", e);
                people = [];
                preferencesState = {};
                nextPersonId = 0;
                peopleContainer.innerHTML = '';
                resultsContainer.innerHTML = '<p style="color: red;">Error loading saved state. Starting fresh.</p>';
                localStorage.removeItem(STORAGE_KEY_PEOPLE);
                localStorage.removeItem(STORAGE_KEY_PREFS);
            }
        }

        // --- UI Rendering ---
        function renderPersonSection(person) {
            const personDiv = document.createElement('div');
            personDiv.classList.add('person-section');
            personDiv.dataset.personId = person.id;
            // Add Remove button next to the name
            personDiv.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                    <h3>${person.name} (ID: ${person.id})</h3>
                    <button type="button" class="remove-person-btn" data-remove-id="${person.id}" style="padding: 2px 5px; font-size: 0.8em; cursor: pointer;">Remove</button>
                </div>`;

            const prefsDiv = document.createElement('div');
            prefsDiv.classList.add('preference-list');
            prefsDiv.innerHTML = `<strong>Preferences towards:</strong>`; // Changed wording

            people.forEach(otherPerson => {
                if (otherPerson.id !== person.id) {
                    // Replace addPreferenceCheckbox with addPreferenceControls
                    addPreferenceControls(prefsDiv, person, otherPerson);
                }
            });

            personDiv.appendChild(prefsDiv);
            return personDiv;
        }

        // Renamed function and added two checkboxes
        function addPreferenceControls(container, personA, personB) {
            const wantKey = `pref_want_${personA.id}_${personB.id}`;
            const dislikeKey = `pref_dislike_${personA.id}_${personB.id}`;
            const wantId = `cb_want_${personA.id}_${personB.id}`;
            const dislikeId = `cb_dislike_${personA.id}_${personB.id}`;

            const neighborDiv = document.createElement('div'); // Container for this neighbor's controls

            // Display Neighbor Name
            const nameSpan = document.createElement('span');
            nameSpan.classList.add('neighbor-name');
            nameSpan.textContent = `${personB.name} (ID: ${personB.id}): `;
            neighborDiv.appendChild(nameSpan);

            // Controls (Want/Dislike)
            const controlsSpan = document.createElement('span');
            controlsSpan.classList.add('pref-controls');

            // "Want" Checkbox
            const wantLabel = document.createElement('label');
            wantLabel.setAttribute('for', wantId);
            const wantCheckbox = document.createElement('input');
            wantCheckbox.type = 'checkbox';
            wantCheckbox.id = wantId;
            wantCheckbox.name = wantKey;
            wantCheckbox.dataset.personAId = personA.id;
            wantCheckbox.dataset.personBId = personB.id;
            wantCheckbox.dataset.prefType = 'want'; // Store type
            wantCheckbox.checked = preferencesState[wantKey] || false;
            wantLabel.appendChild(wantCheckbox);
            wantLabel.appendChild(document.createTextNode(` Want`));
            controlsSpan.appendChild(wantLabel);

            // "Don't Want" Checkbox
            const dislikeLabel = document.createElement('label');
            dislikeLabel.setAttribute('for', dislikeId);
            const dislikeCheckbox = document.createElement('input');
            dislikeCheckbox.type = 'checkbox';
            dislikeCheckbox.id = dislikeId;
            dislikeCheckbox.name = dislikeKey;
            dislikeCheckbox.dataset.personAId = personA.id;
            dislikeCheckbox.dataset.personBId = personB.id;
            dislikeCheckbox.dataset.prefType = 'dislike'; // Store type
            dislikeCheckbox.checked = preferencesState[dislikeKey] || false;
            dislikeLabel.appendChild(dislikeCheckbox);
            dislikeLabel.appendChild(document.createTextNode(` Don't Want`));
            controlsSpan.appendChild(dislikeLabel);

            neighborDiv.appendChild(controlsSpan);
            container.appendChild(neighborDiv);
        }


        function rebuildUI() {
            console.log("[DEBUG] Rebuilding UI from state.");
            peopleContainer.innerHTML = '';
            people.forEach(person => {
                const personDiv = renderPersonSection(person);
                peopleContainer.appendChild(personDiv);
            });
            console.log("[DEBUG] UI Rebuilt.");
        }


        // --- Event Handlers ---
        function handleNameInputKeydown(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                handleAddPerson();
            }
        }

        function handleAddPerson() {
            const name = personNameInput.value.trim();
            if (name === "") {
                console.log("[DEBUG] handleAddPerson called with empty name.");
                return;
            }
            if (people.some(p => p.name === name)) {
                alert(`Person with name "${name}" already exists.`);
                return;
            }

            const newPerson = { id: nextPersonId++, name: name };
            people.push(newPerson);
            console.log(`[DEBUG] Added person: ${JSON.stringify(newPerson)}`);
            rebuildUI(); // Rebuilds with new controls for everyone
            personNameInput.value = '';
            personNameInput.focus();
            debouncedTriggerSolutionUpdate();
        }

        // --- NEW: Handler for Remove Person Button Click (using event delegation) ---
        function handleContainerClick(event) {
            if (event.target.classList.contains('remove-person-btn')) {
                const personIdToRemove = parseInt(event.target.dataset.removeId, 10);
                console.log(`[DEBUG] Remove button clicked for person ID: ${personIdToRemove}`);
                handleRemovePerson(personIdToRemove);
            }
        }

        // --- NEW: Logic to Remove a Person ---
        function handleRemovePerson(personIdToRemove) {
            const personIndex = people.findIndex(p => p.id === personIdToRemove);
            if (personIndex === -1) {
                console.warn(`[DEBUG] handleRemovePerson: Person ID ${personIdToRemove} not found.`);
                return;
            }

            const removedPersonName = people[personIndex].name;
            people.splice(personIndex, 1); // Remove from people array
            console.log(`[DEBUG] Removed person: ${removedPersonName} (ID: ${personIdToRemove})`);

            // Clean up preferences involving the removed person
            const newPreferencesState = {};
            const idString = `_${personIdToRemove}_`;
            for (const key in preferencesState) {
                // Keep preference if it DOES NOT contain _personIdToRemove_
                if (!key.includes(idString)) {
                    newPreferencesState[key] = preferencesState[key];
                } else {
                    console.log(`[DEBUG] Removing preference key related to removed person: ${key}`);
                }
            }
            preferencesState = newPreferencesState;

            rebuildUI(); // Re-render the remaining people and their preferences
            debouncedTriggerSolutionUpdate(); // Recalculate solution
        }

        // --- NEW: Handler for Clear All Button Click ---
        function handleClearAll() {
            if (!confirm("Are you sure you want to remove all people and preferences?")) {
                return;
            }
            console.log("[DEBUG] Clearing all people and preferences.");
            people = [];
            preferencesState = {};
            nextPersonId = 0;
            peopleContainer.innerHTML = ''; // Clear UI
            resultsContainer.innerHTML = '<p>Add people and select preferences to see the results.</p>'; // Reset results
            saveState(); // Save the empty state to localStorage
            // No need to trigger solve, as there's nothing to solve
        }

        function handlePreferenceChange(event) {
            const targetCheckbox = event.target;
            if (targetCheckbox.type === 'checkbox' && targetCheckbox.closest('.person-section')) {
                const personAId = targetCheckbox.dataset.personAId;
                const personBId = targetCheckbox.dataset.personBId;
                const prefType = targetCheckbox.dataset.prefType; // 'want' or 'dislike'
                const isChecked = targetCheckbox.checked;

                console.log(`[DEBUG] Checkbox change: ${prefType} ${personAId}->${personBId} set to ${isChecked}`);

                // Update the state for the changed checkbox
                preferencesState[targetCheckbox.name] = isChecked;

                // If this box was CHECKED, uncheck its sibling
                if (isChecked) {
                    let siblingCheckbox = null;
                    if (prefType === 'want') {
                        const siblingId = `cb_dislike_${personAId}_${personBId}`;
                        siblingCheckbox = peopleContainer.querySelector(`#${siblingId}`);
                    } else { // prefType === 'dislike'
                        const siblingId = `cb_want_${personAId}_${personBId}`;
                        siblingCheckbox = peopleContainer.querySelector(`#${siblingId}`);
                    }

                    if (siblingCheckbox && siblingCheckbox.checked) {
                        console.log(`[DEBUG] Unchecking sibling checkbox: ${siblingCheckbox.name}`);
                        siblingCheckbox.checked = false;
                        // Update sibling state as well
                        preferencesState[siblingCheckbox.name] = false;
                    }
                }
                // No 'else' needed: if a box is unchecked, we just update its state.

                debouncedTriggerSolutionUpdate();
            }
        }

        // --- Solver Logic ---
        async function triggerSolutionUpdate() {
            console.log("[DEBUG] triggerSolutionUpdate called.");
            resultsContainer.innerHTML = '<p><i>Calculating...</i></p>';

            const n = people.length;
            if (n === 0) {
                resultsContainer.innerHTML = '<p>Add people to see results.</p>';
                saveState(); // Save empty state if needed
                return;
            }

            if (!glpk) {
                console.log("[DEBUG] Initializing GLPK...");
                try {
                    glpk = await GLPK();
                    console.log("[DEBUG] GLPK Initialized.");
                } catch (err) {
                    console.error("Failed to initialize GLPK:", err);
                    resultsContainer.innerHTML = '<p style="color: red;">Error initializing solver. Please refresh.</p>';
                    return;
                }
            }

            // Build the preference matrix with 0, 1, or -1
            const preferences = Array(n).fill(0).map(() => Array(n).fill(0));
            const personIdToIndex = new Map(people.map((p, index) => [p.id, index]));

            // Use the current preferencesState
            for (const key in preferencesState) {
                const parts = key.split('_'); // "pref_want_A_B" or "pref_dislike_A_B"
                if (parts.length === 4 && parts[0] === 'pref') {
                    const type = parts[1]; // 'want' or 'dislike'
                    const idA = parseInt(parts[2], 10);
                    const idB = parseInt(parts[3], 10);
                    const indexA = personIdToIndex.get(idA);
                    const indexB = personIdToIndex.get(idB);

                    if (indexA !== undefined && indexB !== undefined) {
                        if (preferencesState[key]) { // If this specific preference is checked
                            if (type === 'want') {
                                preferences[indexA][indexB] = PREFERENCE_VALUE_CHECKED; // 1
                                // console.log(`[DEBUG] Setting preference ${indexA} -> ${indexB} to ${PREFERENCE_VALUE_CHECKED} (Want)`); // Log removed for brevity during run
                            } else if (type === 'dislike') {
                                preferences[indexA][indexB] = PREFERENCE_VALUE_DISLIKE; // -1
                                // console.log(`[DEBUG] Setting preference ${indexA} -> ${indexB} to ${PREFERENCE_VALUE_DISLIKE} (Dislike)`); // Log removed for brevity during run
                            }
                        }
                        // If !preferencesState[key], the value remains 0 (default)
                    } else {
                        console.warn(`[DEBUG] Could not find indices for preference key: ${key}`);
                    }
                }
            }


            console.log("Constructed Preference Matrix (0=Neutral, 1=Want, -1=Dislike):"); // Updated log text
            const preferencesText = preferences.map(row => row.map(v => v.toString().padStart(3)).join(' ')).join("\n"); // Pad for alignment
            console.log(preferencesText);

            // --- Call the solver ---
            // REMINDER: Ensure solve_sitting.mjs uses `preferences[i][j] + preferences[j][i]` in objective!
            console.log("Calling solveSitting...");
            try {
                // Clear previous results before showing new ones
                resultsContainer.innerHTML = ''; // Clear previous results

                const inputMatrixDiv = document.createElement('div');
                inputMatrixDiv.innerHTML = '<h2>Input Preference Matrix:</h2><pre>' + preferencesText + '</pre>';
                resultsContainer.appendChild(inputMatrixDiv);

                const resultMatrix = await solveSitting(glpk, preferences);
                console.log("Solver Result Matrix:");
                console.log(resultMatrix.map(row => row.join(' ')).join("\n"));

                const resultText = resultMatrix.map(row => row.join(' ')).join("\n");
                const rawResultDiv = document.createElement('div');
                rawResultDiv.innerHTML = '<h2>Solver Result Matrix:</h2><pre>' + resultText + '</pre>';
                resultsContainer.appendChild(rawResultDiv);

                // --- NEW: Find and Display Tables ---
                const tables = findTables(resultMatrix, people);
                displayTables(tables, resultsContainer);
                // --- End NEW ---

                saveState(); // Save state after successful solve and UI update

            } catch (error) {
                console.error("Error during solving:", error);
                // Ensure results container is cleared even on error before showing error message
                resultsContainer.innerHTML = '';
                const inputMatrixDiv = document.createElement('div');
                inputMatrixDiv.innerHTML = '<h2>Input Preference Matrix (Solver Failed):</h2><pre>' + preferencesText + '</pre>';
                resultsContainer.appendChild(inputMatrixDiv);
                // Append error message
                const errorDiv = document.createElement('div');
                errorDiv.innerHTML = `<p style="color: red;">Error during solving: ${error.message || error}</p>`;
                resultsContainer.appendChild(errorDiv);
            }
        }

        // Debounced version of the solver trigger
        const debouncedTriggerSolutionUpdate = debounce(triggerSolutionUpdate, DEBOUNCE_DELAY);


        // --- NEW: Find Tables using BFS ---
        function findTables(resultMatrix, people) {
            const n = people.length;
            if (n === 0) return [];

            const indexToPerson = new Map(people.map((p, index) => [index, p]));
            const visited = new Set();
            const tables = [];

            for (let i = 0; i < n; i++) {
                if (!visited.has(i)) {
                    // Start BFS for a new table
                    const currentTablePeople = [];
                    const queue = [i];
                    visited.add(i);
                    console.log(`[DEBUG] findTables: Starting BFS for new table from person index ${i} (${indexToPerson.get(i)?.name})`);

                    while (queue.length > 0) {
                        const currentIdx = queue.shift(); // Dequeue
                        const currentPerson = indexToPerson.get(currentIdx);
                        if (currentPerson) {
                            currentTablePeople.push(currentPerson.name); // Add name to table
                            console.log(`[DEBUG] findTables: Added ${currentPerson.name} (index ${currentIdx}) to current table.`);
                        } else {
                            console.warn(`[DEBUG] findTables: Could not find person for index ${currentIdx}`);
                            currentTablePeople.push(`Unknown (Index ${currentIdx})`);
                        }


                        // Find neighbors
                        for (let neighborIdx = 0; neighborIdx < n; neighborIdx++) {
                            // Check edge exists and neighbor hasn't been visited
                            if (resultMatrix[currentIdx][neighborIdx] === 1 && !visited.has(neighborIdx)) {
                                visited.add(neighborIdx);
                                queue.push(neighborIdx);
                                console.log(`[DEBUG] findTables: Found unvisited neighbor ${indexToPerson.get(neighborIdx)?.name} (index ${neighborIdx}), adding to queue.`);
                            }
                        }
                    }
                    // BFS for this component is done, add the found table
                    if (currentTablePeople.length > 0) {
                        console.log(`[DEBUG] findTables: Finished table: [${currentTablePeople.join(', ')}]`);
                        tables.push(currentTablePeople);
                    } else {
                        console.log(`[DEBUG] findTables: Finished BFS for index ${i}, but table was empty?`);
                    }
                }
            }

            if (visited.size !== n) {
                console.warn(`[DEBUG] findTables: Visited count (${visited.size}) does not match total people (${n}). Some people might be isolated.`);
                // Add isolated people as tables of one
                for (let i = 0; i < n; i++) {
                    if (!visited.has(i)) {
                        const isolatedPerson = indexToPerson.get(i);
                        if (isolatedPerson) {
                            console.log(`[DEBUG] findTables: Adding isolated person ${isolatedPerson.name} as a table.`);
                            tables.push([isolatedPerson.name]);
                        } else {
                            tables.push([`Unknown (Index ${i})`]);
                        }
                    }
                }
            }


            console.log("[DEBUG] findTables: Final tables found:", JSON.stringify(tables));
            return tables;
        }

        // --- NEW: Display Tables using Enhanced SVG ---
        function displayTables(tables, container) {
            container.innerHTML = '<h3>Sitting Arrangement (Tables):</h3>'; // Clear previous content and add title

            if (tables.length === 0) {
                let message = '';
                if (people.length > 0) {
                    message = '<p style="color: orange;">Could not determine any seating arrangements (maybe no one sits together?).</p>';
                } else {
                    message = '<p>No people defined.</p>';
                }
                container.innerHTML += message;
                return;
            }

            // --- Create SVG Canvas ---
            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, "svg");

            // Calculate required radius for positioning elements (table + person circle + text offset)
            const outerRadius = TABLE_RADIUS + PERSON_CIRCLE_RADIUS + PERSON_TEXT_OFFSET + PERSON_FONT_SIZE; // Approximate outer boundary
            const svgHeight = TOP_PADDING + (outerRadius * 2) + TOP_PADDING;
            svg.setAttribute("height", svgHeight);
            svg.setAttribute("style", "display: block; margin: auto; width: 100%; max-width: 100%;"); // Responsive width

            let currentXOffset = TABLE_PADDING + outerRadius; // Start X for the center of the first table's outer bounds

            tables.forEach((table, tableIndex) => {
                const numPeople = table.length;
                if (numPeople === 0) return;

                const tableCenterX = currentXOffset;
                const tableCenterY = TOP_PADDING + outerRadius; // Center based on the overall element height

                // --- Create Group for this Table ---
                const tableGroup = document.createElementNS(svgNS, "g");

                // --- Draw Table Circle ---
                const tableCircle = document.createElementNS(svgNS, "circle");
                tableCircle.setAttribute("cx", tableCenterX);
                tableCircle.setAttribute("cy", tableCenterY);
                tableCircle.setAttribute("r", TABLE_RADIUS);
                tableCircle.setAttribute("stroke", TABLE_STROKE_COLOR);
                tableCircle.setAttribute("stroke-width", "3"); // Slightly thicker stroke
                tableCircle.setAttribute("fill", TABLE_FILL_COLOR);
                tableGroup.appendChild(tableCircle);

                // --- Place People around the Table ---
                table.sort(); // Keep consistent placement

                const angleStep = (2 * Math.PI) / numPeople;

                table.forEach((personName, personIndex) => {
                    // Calculate angle: Start at top (-PI/2) and go clockwise
                    const angle = -Math.PI / 2 + personIndex * angleStep;
                    const cosAngle = Math.cos(angle);
                    const sinAngle = Math.sin(angle);

                    // 1. Calculate Person Circle Position (on the table radius)
                    const personX = tableCenterX + TABLE_RADIUS * cosAngle;
                    const personY = tableCenterY + TABLE_RADIUS * sinAngle;

                    // Draw Person Circle
                    const personCircle = document.createElementNS(svgNS, "circle");
                    personCircle.setAttribute("cx", personX);
                    personCircle.setAttribute("cy", personY);
                    personCircle.setAttribute("r", PERSON_CIRCLE_RADIUS);
                    personCircle.setAttribute("fill", PERSON_FILL_COLOR);
                    // Optional: Add a subtle stroke to person circles
                    // personCircle.setAttribute("stroke", "#fff");
                    // personCircle.setAttribute("stroke-width", "1");
                    tableGroup.appendChild(personCircle);

                    // 2. Calculate Text Position (outside the person circle)
                    const textRadius = TABLE_RADIUS + PERSON_CIRCLE_RADIUS + PERSON_TEXT_OFFSET;
                    const textX = tableCenterX + textRadius * cosAngle;
                    const textY = tableCenterY + textRadius * sinAngle;

                    // Draw Person Name Text
                    const text = document.createElementNS(svgNS, "text");
                    text.setAttribute("x", textX);
                    text.setAttribute("y", textY);

                    // Adjust alignment based on angle for better readability
                    if (Math.abs(cosAngle) < 0.1) { // Near vertical (top/bottom)
                        text.setAttribute("text-anchor", "middle");
                    } else if (cosAngle > 0) { // Right side
                        text.setAttribute("text-anchor", "start");
                    } else { // Left side
                        text.setAttribute("text-anchor", "end");
                    }
                    text.setAttribute("dominant-baseline", "middle"); // Vertically center
                    text.setAttribute("font-size", `${PERSON_FONT_SIZE}px`);
                    text.setAttribute("font-family", "sans-serif"); // Specify a common font
                    text.setAttribute("fill", TEXT_COLOR);
                    text.textContent = personName;

                    tableGroup.appendChild(text);
                });

                // Append the finished table group to the SVG
                svg.appendChild(tableGroup);

                // Update X offset for the next table's center (based on outer bounds)
                currentXOffset += (outerRadius * 2) + TABLE_PADDING;
            });

            // Set final SVG width based on the last table's position
            const svgWidth = currentXOffset - TABLE_PADDING + outerRadius; // Total width needed
            svg.setAttribute("width", svgWidth > 0 ? svgWidth : "100"); // Use minimum width if calculation fails
            // Set viewBox for proper scaling if width is responsive
            svg.setAttribute("viewBox", `0 0 ${svgWidth > 0 ? svgWidth : 100} ${svgHeight}`);

            // Append the SVG to the container
            container.appendChild(svg);
        }


        // --- Initialization ---
        addPersonBtn.addEventListener('click', handleAddPerson);
        personNameInput.addEventListener('keydown', handleNameInputKeydown);
        peopleContainer.addEventListener('change', handlePreferenceChange);
        // --- NEW: Add event listeners for remove and clear ---
        peopleContainer.addEventListener('click', handleContainerClick); // Listener for remove buttons
        clearAllBtn.addEventListener('click', handleClearAll);         // Listener for clear all button

        loadState();

    </script>

</body>

</html>